(function () {
    let eyeTimer = null;
    const EYE_THRESHOLD = 3000;

    let lastWarningTime = 0;
    const WARNING_COOLDOWN = 5000;
    const eyeWarningTimestamps = [];
    const MAX_WARNINGS_PER_MINUTE = 9;
    const TIME_WINDOW_MS = 60 * 1000;

    const FACE_AREA_THRESHOLD = 0.01;
    const DEBUG_DRAW_BOXES = false;

    function canTriggerWarning() {
        const now = Date.now();
        return (now - lastWarningTime) > WARNING_COOLDOWN;
    }

    function cleanupOldWarnings() {
        const now = Date.now();
        while (eyeWarningTimestamps.length && now - eyeWarningTimestamps[0] > TIME_WINDOW_MS) {
            eyeWarningTimestamps.shift();
        }
    }

    function triggerWarning(status, data, callback) {
        if (!canTriggerWarning()) return;

        lastWarningTime = Date.now();
        callback({ status, data });

        if (status === 'eyesnotopen') {
            const now = Date.now();
            eyeWarningTimestamps.push(now);
            cleanupOldWarnings();

            if (eyeWarningTimestamps.length > MAX_WARNINGS_PER_MINUTE) {
                callback({ status: 'eyecheckoff', data });
            }
        }
    }

    async function waitForVideoReady(videoElement) {
        while (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    async function setupFaceMesh(videoElement, canvasElement, faceMesh, detectionval, callback) {
        const canvasCtx = canvasElement.getContext('2d');
        await waitForVideoReady(videoElement);
        
        faceMesh.setOptions({
            maxNumFaces: 5,
            refineLandmarks: true,
        });

        faceMesh.onResults((results) => {
            // Always render results
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.restore();

            const data = canvasElement.toDataURL('image/png');
            runDetection(results, data, detectionval, callback, canvasElement);
        });

        async function sendFrame() {
            await faceMesh.send({ image: videoElement });
            requestAnimationFrame(sendFrame);
        }

        sendFrame();
    }

    function runDetection(results, data, detectionval, callback, canvasElement) {
        const eyecheckoff = JSON.parse(localStorage.getItem('eyecheckoff')) || false;
        const FACE_AREA_THRESHOLD = 0.01; // Tune based on resolution
        const DEBUG_DRAW_BOXES = false; // Set to true for visual debug

        if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
            triggerWarning('noface', data, callback);
            return;
        }

        // Step 1: Filter small/invalid faces
        const validFaces = results.multiFaceLandmarks.filter(landmarks => {
            let minX = 1, maxX = 0, minY = 1, maxY = 0;
            landmarks.forEach(p => {
                if (p.x < minX) minX = p.x;
                if (p.x > maxX) maxX = p.x;
                if (p.y < minY) minY = p.y;
                if (p.y > maxY) maxY = p.y;
            });
            const area = (maxX - minX) * (maxY - minY);
            return area > FACE_AREA_THRESHOLD;
        });

        if (validFaces.length === 0) {
            triggerWarning('noface', data, callback);
            return;
        }

        // Step 2: Optional debug box draw
        if (DEBUG_DRAW_BOXES && canvasElement) {
            const ctx = canvasElement.getContext('2d');
            validFaces.forEach(landmarks => {
                let minX = 1, maxX = 0, minY = 1, maxY = 0;
                landmarks.forEach(p => {
                    if (p.x < minX) minX = p.x;
                    if (p.x > maxX) maxX = p.x;
                    if (p.y < minY) minY = p.y;
                    if (p.y > maxY) maxY = p.y;
                });
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 2;
                ctx.strokeRect(
                    minX * canvasElement.width,
                    minY * canvasElement.height,
                    (maxX - minX) * canvasElement.width,
                    (maxY - minY) * canvasElement.height
                );
            });
        }

        // Step 3: Advanced multiface detection (area + distance check)
        if (validFaces.length > 1) {
            const faceData = validFaces.map(landmarks => {
                let minX = 1, maxX = 0, minY = 1, maxY = 0;
                let cx = 0, cy = 0;
                landmarks.forEach(p => {
                    if (p.x < minX) minX = p.x;
                    if (p.x > maxX) maxX = p.x;
                    if (p.y < minY) minY = p.y;
                    if (p.y > maxY) maxY = p.y;
                    cx += p.x;
                    cy += p.y;
                });
                const count = landmarks.length;
                cx /= count;
                cy /= count;
                const area = (maxX - minX) * (maxY - minY);
                return { landmarks, area, center: { x: cx, y: cy } };
            });

            faceData.sort((a, b) => b.area - a.area);
            const main = faceData[0];
            const second = faceData[1];

            if (second) {
                const ratio = second.area / main.area;
                const dx = main.center.x - second.center.x;
                const dy = main.center.y - second.center.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const DISTANCE_THRESHOLD = 0.08;

                if (ratio > 0.25 && distance > DISTANCE_THRESHOLD) {
                    console.log('Multiface Detected ? Ratio:', ratio, 'Distance:', distance);
                    triggerWarning('multiface', data, callback);
                    return;
                }
            }
        }

        // Step 4: Run detection on the largest face
        const landmarks = validFaces[0];

        if (!eyecheckoff && (detectionval === null || detectionval === 1)) {
            detectEyeStatus(landmarks, data, callback);
        }
        detectEyeDirection(landmarks, data, callback);
    }

    function detectEyeStatus(landmarks, data, callback) {
        const leftEyeUpper = landmarks[159];
        const leftEyeLower = landmarks[145];
        const rightEyeUpper = landmarks[386];
        const rightEyeLower = landmarks[374];

        const leftEar = landmarks[234];
        const rightEar = landmarks[454];
        const nose = landmarks[1];

        if (!leftEyeUpper || !leftEyeLower || !rightEyeUpper || !rightEyeLower ||
            !leftEar || !rightEar || !nose) {
            triggerWarning('eyesnotopen', data, callback);
            return;
        }

        const leftEyeOpen = Math.abs(leftEyeUpper.y - leftEyeLower.y);
        const rightEyeOpen = Math.abs(rightEyeUpper.y - rightEyeLower.y);
        const EYE_OPEN_THRESHOLD = 0.015;

        const isClosed = leftEyeOpen < EYE_OPEN_THRESHOLD && rightEyeOpen < EYE_OPEN_THRESHOLD;

        if (isClosed && !eyeTimer) {
            eyeTimer = setTimeout(() => {
                triggerWarning('eyesnotopen', data, callback);
                eyeTimer = null;
            }, EYE_THRESHOLD);
        } else if (!isClosed && eyeTimer) {
            clearTimeout(eyeTimer);
            eyeTimer = null;
        }
    }

    function detectEyeDirection(landmarks, data, callback) {
        const leftIris = landmarks[468];
        const leftEyeInner = landmarks[133];
        const leftEyeOuter = landmarks[33];
        const leftEyeTop = landmarks[159];
        const leftEyeBottom = landmarks[145];

        if (!leftIris || !leftEyeInner || !leftEyeOuter || !leftEyeTop || !leftEyeBottom) return;

        const horizontalRatio = (leftIris.x - leftEyeInner.x) / (leftEyeOuter.x - leftEyeInner.x);
        const verticalRatio = (leftIris.y - leftEyeTop.y) / (leftEyeBottom.y - leftEyeTop.y);

        let direction = "center";

        if (horizontalRatio < 0.30) {
            direction = "left";
        } else if (horizontalRatio > 0.70) {
            direction = "right";
        }

        if (direction !== "center") {
            triggerWarning(`eyesnotopen`, data, callback);
        }
    }

    window.setupFaceMesh = setupFaceMesh;
})();