(function () {
    let eyeTimer = null;
    const EYE_THRESHOLD = 3000;
    const WARNING_COOLDOWN = 5000;

    let lastWarningTime = 0;

    const eyeWarningTimestamps = [];
    const MAX_WARNINGS_PER_MINUTE = 9;
    const TIME_WINDOW_MS = 60 * 1000;

    function canTriggerWarning() {
        return (Date.now() - lastWarningTime) > WARNING_COOLDOWN;
    }

    function cleanupOldWarnings() {
        const now = Date.now();
        while (eyeWarningTimestamps.length && now - eyeWarningTimestamps[0] > TIME_WINDOW_MS) {
            eyeWarningTimestamps.shift();
        }
    }

    function triggerWarning(status, data, callback) {
        if (!canTriggerWarning()) return;

        lastWarningTime = Date.now();
        callback({ status, data });

        if (status === 'eyesnotopen') {
            const now = Date.now();
            eyeWarningTimestamps.push(now);
            cleanupOldWarnings();

            if (eyeWarningTimestamps.length > MAX_WARNINGS_PER_MINUTE) {
            	console.log('hey');
                callback({ status: 'eyecheckoff', data });
            }
        }
    }

    async function waitForVideoReady(videoElement) {
        while (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    async function setupFaceMesh(videoElement, canvasElement, faceMesh, callback) {
        const canvasCtx = canvasElement.getContext('2d');
        await waitForVideoReady(videoElement);
        
        faceMesh.setOptions({
            maxNumFaces: 5,
            refineLandmarks: true,
        });

        faceMesh.onResults((results) => {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            const data = canvasElement.toDataURL('image/png');
            let returnData = { status: '', data: data };

            if (results.multiFaceLandmarks?.length === 1) {
                const landmarks = results.multiFaceLandmarks[0];
                var eyecheckoff = JSON.parse(localStorage.getItem('eyecheckoff')) || false;
                if (!eyecheckoff) {
	                detectEyeStatus(landmarks, data, callback);
	            }
                detectEyeDirection(landmarks, data, callback);
            }

            canvasCtx.restore();
            callback(returnData);
        });

        async function sendFaceMeshData() {
            await faceMesh.send({ image: videoElement });
            requestAnimationFrame(sendFaceMeshData);
        }

        sendFaceMeshData();
    }

    function detectEyeStatus(landmarks, data, callback) {
        const leftEyeUpper = landmarks[159];
        const leftEyeLower = landmarks[145];
        const rightEyeUpper = landmarks[386];
        const rightEyeLower = landmarks[374];

        const leftEar = landmarks[234];
        const rightEar = landmarks[454];
        const nose = landmarks[1];

        if (!leftEyeUpper || !leftEyeLower || !rightEyeUpper || !rightEyeLower ||
            !leftEar || !rightEar || !nose) {
            triggerWarning('eyesnotopen', data, callback);
            return;
        }

        const leftEyeOpen = Math.abs(leftEyeUpper.y - leftEyeLower.y);
        const rightEyeOpen = Math.abs(rightEyeUpper.y - rightEyeLower.y);
        const EYE_OPEN_THRESHOLD = 0.015;

        const isClosed = leftEyeOpen < EYE_OPEN_THRESHOLD && rightEyeOpen < EYE_OPEN_THRESHOLD;

        const eyesAvgY = (leftEyeUpper.y + rightEyeUpper.y) / 2;
        const lookingDown = (nose.y - eyesAvgY) > 0.04;

        if (isClosed && !eyeTimer) {
            eyeTimer = setTimeout(() => {
                triggerWarning('eyesnotopen', data, callback);
                eyeTimer = null;
            }, EYE_THRESHOLD);
        } else if (!isClosed && eyeTimer) {
            clearTimeout(eyeTimer);
            eyeTimer = null;
        }
    }

    function detectEyeDirection(landmarks, data, callback) {
        const leftIris = landmarks[468]; // center of left iris
        const leftEyeInner = landmarks[133]; // inner eye corner
        const leftEyeOuter = landmarks[33];  // outer eye corner
        const leftEyeTop = landmarks[159];
        const leftEyeBottom = landmarks[145];

        if (!leftIris || !leftEyeInner || !leftEyeOuter || !leftEyeTop || !leftEyeBottom) return;

        const horizontalRatio = (leftIris.x - leftEyeInner.x) / (leftEyeOuter.x - leftEyeInner.x);
        const verticalRatio = (leftIris.y - leftEyeTop.y) / (leftEyeBottom.y - leftEyeTop.y);

        let direction = "center";

        if (horizontalRatio < 0.30) {
            direction = "left";
        } else if (horizontalRatio > 0.70) {
            direction = "right";
        }

        if (direction !== "center") {
            triggerWarning(`eyesnotopen`, data, callback);
        }
    }

    window.setupFaceMesh = setupFaceMesh;
})();