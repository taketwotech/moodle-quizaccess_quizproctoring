(function () {
    let eyeTimer = null;
    let directionTimer = null;
    let directionTimerStart = null;
    let lastDirection = "center";
    const EYE_THRESHOLD = 3000;
    const DIRECTION_THRESHOLD = 3000;
    const WARNING_COOLDOWN = 5000;

    let lastWarningTime = 0;

    const eyeWarningTimestamps = [];
    const MAX_WARNINGS_PER_MINUTE = 4;
    const TIME_WINDOW_MS = 30 * 1000;

    function canTriggerWarning() {
        return (Date.now() - lastWarningTime) > WARNING_COOLDOWN;
    }

    function cleanupOldWarnings() {
        const now = Date.now();
        while (eyeWarningTimestamps.length && now - eyeWarningTimestamps[0] > TIME_WINDOW_MS) {
            eyeWarningTimestamps.shift();
        }
    }

    function triggerWarning(status, data, callback) {
        if (!canTriggerWarning()) return;

        lastWarningTime = Date.now();
        callback({ status, data });

        if (status === 'eyesnotopen') {
            const now = Date.now();
            eyeWarningTimestamps.push(now);
            cleanupOldWarnings();

            if (eyeWarningTimestamps.length > MAX_WARNINGS_PER_MINUTE) {
                callback({ status: 'eyecheckoff', data });
            }
        }
    }

    async function waitForVideoReady(videoElement) {
        while (videoElement.videoWidth === 0 || videoElement.videoHeight === 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    async function setupFaceMesh(videoElement, canvasElement, faceMesh, detectionval, callback) {
        const canvasCtx = canvasElement.getContext('2d');
        await waitForVideoReady(videoElement);
        
        faceMesh.setOptions({
            maxNumFaces: 5,
            refineLandmarks: true,
        });

        faceMesh.onResults((results) => {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);
            const data = canvasElement.toDataURL('image/png');
            let returnData = { status: '', data: data };

            if (results.multiFaceLandmarks?.length === 1) {
                const landmarks = results.multiFaceLandmarks[0];
                detectEyeStatus(landmarks, data, callback);
                detectEyeDirection(landmarks, data, callback);
            }

            canvasCtx.restore();
            callback(returnData);
        });

        async function sendFaceMeshData() {
            await faceMesh.send({ image: videoElement });
            requestAnimationFrame(sendFaceMeshData);
        }

        sendFaceMeshData();
    }

    function detectEyeStatus(landmarks, data, callback) {
        const leftEyeUpper = landmarks[159];
        const leftEyeLower = landmarks[145];
        const rightEyeUpper = landmarks[386];
        const rightEyeLower = landmarks[374];

        const leftEar = landmarks[234];
        const rightEar = landmarks[454];
        const nose = landmarks[1];

        if (!leftEyeUpper || !leftEyeLower || !rightEyeUpper || !rightEyeLower ||
            !leftEar || !rightEar || !nose) {
            triggerWarning('eyesnotopen', data, callback);
            return;
        }

        const leftEyeOpen = Math.abs(leftEyeUpper.y - leftEyeLower.y);
        const rightEyeOpen = Math.abs(rightEyeUpper.y - rightEyeLower.y);
        const EYE_OPEN_THRESHOLD = 0.015;

        const isClosed = leftEyeOpen < EYE_OPEN_THRESHOLD && rightEyeOpen < EYE_OPEN_THRESHOLD;

        const eyesAvgY = (leftEyeUpper.y + rightEyeUpper.y) / 2;
        const lookingDown = (nose.y - eyesAvgY) > 0.04;

        if (isClosed && !eyeTimer) {
            eyeTimer = setTimeout(() => {
                triggerWarning('eyesnotopen', data, callback);
                eyeTimer = null;
            }, EYE_THRESHOLD);
        } else if (!isClosed && eyeTimer) {
            clearTimeout(eyeTimer);
            eyeTimer = null;
        }
    }

    function detectEyeDirection(landmarks, data, callback) {
        const leftIris = landmarks[468]; // center of left iris
        const leftEyeInner = landmarks[133]; // inner eye corner
        const leftEyeOuter = landmarks[33];  // outer eye corner
        const leftEyeTop = landmarks[159];
        const leftEyeBottom = landmarks[145];

        if (!leftIris || !leftEyeInner || !leftEyeOuter || !leftEyeTop || !leftEyeBottom) {
            if (directionTimer) {
                clearTimeout(directionTimer);
                directionTimer = null;
                directionTimerStart = null;
            }
            lastDirection = "center";
            return;
        }

        const horizontalRatio = (leftIris.x - leftEyeInner.x) / (leftEyeOuter.x - leftEyeInner.x);
        const verticalRatio = (leftIris.y - leftEyeTop.y) / (leftEyeBottom.y - leftEyeTop.y);

        let direction = "center";

        if (horizontalRatio < 0.35) {
            direction = "left";
        } else if (horizontalRatio > 0.70) {
            direction = "right";
        }

        if (direction !== "center") {
            console.log(`Direction: ${direction}, Ratio: ${horizontalRatio.toFixed(3)}`);
        }

        if (direction === "center" && directionTimer) {
            clearTimeout(directionTimer);
            directionTimer = null;
            directionTimerStart = null;
            console.log("Back to center - Timer cleared");
        } else if (direction !== "center" && lastDirection === "center" && directionTimer) {
            clearTimeout(directionTimer);
            directionTimer = null;
            directionTimerStart = null;
            console.log("Direction changed from center, timer reset");
        } else if (direction !== "center" && lastDirection !== "center" && direction !== lastDirection && directionTimer) {
            clearTimeout(directionTimer);
            directionTimer = null;
            directionTimerStart = null;
            console.log(`Direction changed from ${lastDirection} to ${direction}, timer reset`);
        }

        if (direction !== "center" && !directionTimer) {
            directionTimerStart = Date.now();
            console.log(`Looking ${direction} - Timer started. Ratio: ${horizontalRatio.toFixed(3)}`);
            directionTimer = setTimeout(() => {
                console.log(`Warning triggered after ${DIRECTION_THRESHOLD}ms - ${direction}`);
                triggerWarning(`eyesnotopen`, data, callback);
                directionTimer = null;
                directionTimerStart = null;
            }, DIRECTION_THRESHOLD);
        } else if (direction !== "center" && directionTimer && directionTimerStart) {
            const elapsed = Date.now() - directionTimerStart;
            const remaining = DIRECTION_THRESHOLD - elapsed;
            console.log(`Looking ${direction} - ${remaining.toFixed(0)}ms remaining. Ratio: ${horizontalRatio.toFixed(3)}`);
        }

        lastDirection = direction;
    }

    window.setupFaceMesh = setupFaceMesh;
})();